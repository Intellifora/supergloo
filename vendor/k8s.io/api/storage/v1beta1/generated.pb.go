// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/supergloo/vendor/k8s.io/api/storage/v1beta1/generated.proto

package v1beta1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import v11 "k8s.io/api/core/v1"
import v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
import _ "k8s.io/apimachinery/pkg/runtime"
import _ "k8s.io/apimachinery/pkg/runtime/schema"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// StorageClass describes the parameters for a class of storage for
// which PersistentVolumes can be dynamically provisioned.
//
// StorageClasses are non-namespaced; the name of the storage class
// according to etcd is in ObjectMeta.Name.
type StorageClass struct {
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	Metadata *v1.ObjectMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Provisioner indicates the type of the provisioner.
	Provisioner *string `protobuf:"bytes,2,opt,name=provisioner" json:"provisioner,omitempty"`
	// Parameters holds the parameters for the provisioner that should
	// create volumes of this storage class.
	// +optional
	Parameters map[string]string `protobuf:"bytes,3,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Dynamically provisioned PersistentVolumes of this storage class are
	// created with this reclaimPolicy. Defaults to Delete.
	// +optional
	ReclaimPolicy *string `protobuf:"bytes,4,opt,name=reclaimPolicy" json:"reclaimPolicy,omitempty"`
	// Dynamically provisioned PersistentVolumes of this storage class are
	// created with these mountOptions, e.g. ["ro", "soft"]. Not validated -
	// mount of the PVs will simply fail if one is invalid.
	// +optional
	MountOptions []string `protobuf:"bytes,5,rep,name=mountOptions" json:"mountOptions,omitempty"`
	// AllowVolumeExpansion shows whether the storage class allow volume expand
	// +optional
	AllowVolumeExpansion *bool `protobuf:"varint,6,opt,name=allowVolumeExpansion" json:"allowVolumeExpansion,omitempty"`
	// VolumeBindingMode indicates how PersistentVolumeClaims should be
	// provisioned and bound.  When unset, VolumeBindingImmediate is used.
	// This field is only honored by servers that enable the VolumeScheduling feature.
	// +optional
	VolumeBindingMode *string `protobuf:"bytes,7,opt,name=volumeBindingMode" json:"volumeBindingMode,omitempty"`
	// Restrict the node topologies where volumes can be dynamically provisioned.
	// Each volume plugin defines its own supported topology specifications.
	// An empty TopologySelectorTerm list means there is no topology restriction.
	// This field is only honored by servers that enable the VolumeScheduling feature.
	// +optional
	AllowedTopologies    []*v11.TopologySelectorTerm `protobuf:"bytes,8,rep,name=allowedTopologies" json:"allowedTopologies,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *StorageClass) Reset()         { *m = StorageClass{} }
func (m *StorageClass) String() string { return proto.CompactTextString(m) }
func (*StorageClass) ProtoMessage()    {}
func (*StorageClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_generated_e6465b2805f8299b, []int{0}
}
func (m *StorageClass) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageClass.Unmarshal(m, b)
}
func (m *StorageClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageClass.Marshal(b, m, deterministic)
}
func (dst *StorageClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageClass.Merge(dst, src)
}
func (m *StorageClass) XXX_Size() int {
	return xxx_messageInfo_StorageClass.Size(m)
}
func (m *StorageClass) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageClass.DiscardUnknown(m)
}

var xxx_messageInfo_StorageClass proto.InternalMessageInfo

func (m *StorageClass) GetMetadata() *v1.ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *StorageClass) GetProvisioner() string {
	if m != nil && m.Provisioner != nil {
		return *m.Provisioner
	}
	return ""
}

func (m *StorageClass) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *StorageClass) GetReclaimPolicy() string {
	if m != nil && m.ReclaimPolicy != nil {
		return *m.ReclaimPolicy
	}
	return ""
}

func (m *StorageClass) GetMountOptions() []string {
	if m != nil {
		return m.MountOptions
	}
	return nil
}

func (m *StorageClass) GetAllowVolumeExpansion() bool {
	if m != nil && m.AllowVolumeExpansion != nil {
		return *m.AllowVolumeExpansion
	}
	return false
}

func (m *StorageClass) GetVolumeBindingMode() string {
	if m != nil && m.VolumeBindingMode != nil {
		return *m.VolumeBindingMode
	}
	return ""
}

func (m *StorageClass) GetAllowedTopologies() []*v11.TopologySelectorTerm {
	if m != nil {
		return m.AllowedTopologies
	}
	return nil
}

// StorageClassList is a collection of storage classes.
type StorageClassList struct {
	// Standard list metadata
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	Metadata *v1.ListMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Items is the list of StorageClasses
	Items                []*StorageClass `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *StorageClassList) Reset()         { *m = StorageClassList{} }
func (m *StorageClassList) String() string { return proto.CompactTextString(m) }
func (*StorageClassList) ProtoMessage()    {}
func (*StorageClassList) Descriptor() ([]byte, []int) {
	return fileDescriptor_generated_e6465b2805f8299b, []int{1}
}
func (m *StorageClassList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageClassList.Unmarshal(m, b)
}
func (m *StorageClassList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageClassList.Marshal(b, m, deterministic)
}
func (dst *StorageClassList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageClassList.Merge(dst, src)
}
func (m *StorageClassList) XXX_Size() int {
	return xxx_messageInfo_StorageClassList.Size(m)
}
func (m *StorageClassList) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageClassList.DiscardUnknown(m)
}

var xxx_messageInfo_StorageClassList proto.InternalMessageInfo

func (m *StorageClassList) GetMetadata() *v1.ListMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *StorageClassList) GetItems() []*StorageClass {
	if m != nil {
		return m.Items
	}
	return nil
}

// VolumeAttachment captures the intent to attach or detach the specified volume
// to/from the specified node.
//
// VolumeAttachment objects are non-namespaced.
type VolumeAttachment struct {
	// Standard object metadata.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	Metadata *v1.ObjectMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Specification of the desired attach/detach volume behavior.
	// Populated by the Kubernetes system.
	Spec *VolumeAttachmentSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	// Status of the VolumeAttachment request.
	// Populated by the entity completing the attach or detach
	// operation, i.e. the external-attacher.
	// +optional
	Status               *VolumeAttachmentStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *VolumeAttachment) Reset()         { *m = VolumeAttachment{} }
func (m *VolumeAttachment) String() string { return proto.CompactTextString(m) }
func (*VolumeAttachment) ProtoMessage()    {}
func (*VolumeAttachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_generated_e6465b2805f8299b, []int{2}
}
func (m *VolumeAttachment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeAttachment.Unmarshal(m, b)
}
func (m *VolumeAttachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeAttachment.Marshal(b, m, deterministic)
}
func (dst *VolumeAttachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeAttachment.Merge(dst, src)
}
func (m *VolumeAttachment) XXX_Size() int {
	return xxx_messageInfo_VolumeAttachment.Size(m)
}
func (m *VolumeAttachment) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeAttachment.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeAttachment proto.InternalMessageInfo

func (m *VolumeAttachment) GetMetadata() *v1.ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *VolumeAttachment) GetSpec() *VolumeAttachmentSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *VolumeAttachment) GetStatus() *VolumeAttachmentStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// VolumeAttachmentList is a collection of VolumeAttachment objects.
type VolumeAttachmentList struct {
	// Standard list metadata
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	Metadata *v1.ListMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Items is the list of VolumeAttachments
	Items                []*VolumeAttachment `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *VolumeAttachmentList) Reset()         { *m = VolumeAttachmentList{} }
func (m *VolumeAttachmentList) String() string { return proto.CompactTextString(m) }
func (*VolumeAttachmentList) ProtoMessage()    {}
func (*VolumeAttachmentList) Descriptor() ([]byte, []int) {
	return fileDescriptor_generated_e6465b2805f8299b, []int{3}
}
func (m *VolumeAttachmentList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeAttachmentList.Unmarshal(m, b)
}
func (m *VolumeAttachmentList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeAttachmentList.Marshal(b, m, deterministic)
}
func (dst *VolumeAttachmentList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeAttachmentList.Merge(dst, src)
}
func (m *VolumeAttachmentList) XXX_Size() int {
	return xxx_messageInfo_VolumeAttachmentList.Size(m)
}
func (m *VolumeAttachmentList) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeAttachmentList.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeAttachmentList proto.InternalMessageInfo

func (m *VolumeAttachmentList) GetMetadata() *v1.ListMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *VolumeAttachmentList) GetItems() []*VolumeAttachment {
	if m != nil {
		return m.Items
	}
	return nil
}

// VolumeAttachmentSource represents a volume that should be attached.
// Right now only PersistenVolumes can be attached via external attacher,
// in future we may allow also inline volumes in pods.
// Exactly one member can be set.
type VolumeAttachmentSource struct {
	// Name of the persistent volume to attach.
	// +optional
	PersistentVolumeName *string  `protobuf:"bytes,1,opt,name=persistentVolumeName" json:"persistentVolumeName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeAttachmentSource) Reset()         { *m = VolumeAttachmentSource{} }
func (m *VolumeAttachmentSource) String() string { return proto.CompactTextString(m) }
func (*VolumeAttachmentSource) ProtoMessage()    {}
func (*VolumeAttachmentSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_generated_e6465b2805f8299b, []int{4}
}
func (m *VolumeAttachmentSource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeAttachmentSource.Unmarshal(m, b)
}
func (m *VolumeAttachmentSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeAttachmentSource.Marshal(b, m, deterministic)
}
func (dst *VolumeAttachmentSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeAttachmentSource.Merge(dst, src)
}
func (m *VolumeAttachmentSource) XXX_Size() int {
	return xxx_messageInfo_VolumeAttachmentSource.Size(m)
}
func (m *VolumeAttachmentSource) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeAttachmentSource.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeAttachmentSource proto.InternalMessageInfo

func (m *VolumeAttachmentSource) GetPersistentVolumeName() string {
	if m != nil && m.PersistentVolumeName != nil {
		return *m.PersistentVolumeName
	}
	return ""
}

// VolumeAttachmentSpec is the specification of a VolumeAttachment request.
type VolumeAttachmentSpec struct {
	// Attacher indicates the name of the volume driver that MUST handle this
	// request. This is the name returned by GetPluginName().
	Attacher *string `protobuf:"bytes,1,opt,name=attacher" json:"attacher,omitempty"`
	// Source represents the volume that should be attached.
	Source *VolumeAttachmentSource `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	// The node that the volume should be attached to.
	NodeName             *string  `protobuf:"bytes,3,opt,name=nodeName" json:"nodeName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeAttachmentSpec) Reset()         { *m = VolumeAttachmentSpec{} }
func (m *VolumeAttachmentSpec) String() string { return proto.CompactTextString(m) }
func (*VolumeAttachmentSpec) ProtoMessage()    {}
func (*VolumeAttachmentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_generated_e6465b2805f8299b, []int{5}
}
func (m *VolumeAttachmentSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeAttachmentSpec.Unmarshal(m, b)
}
func (m *VolumeAttachmentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeAttachmentSpec.Marshal(b, m, deterministic)
}
func (dst *VolumeAttachmentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeAttachmentSpec.Merge(dst, src)
}
func (m *VolumeAttachmentSpec) XXX_Size() int {
	return xxx_messageInfo_VolumeAttachmentSpec.Size(m)
}
func (m *VolumeAttachmentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeAttachmentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeAttachmentSpec proto.InternalMessageInfo

func (m *VolumeAttachmentSpec) GetAttacher() string {
	if m != nil && m.Attacher != nil {
		return *m.Attacher
	}
	return ""
}

func (m *VolumeAttachmentSpec) GetSource() *VolumeAttachmentSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *VolumeAttachmentSpec) GetNodeName() string {
	if m != nil && m.NodeName != nil {
		return *m.NodeName
	}
	return ""
}

// VolumeAttachmentStatus is the status of a VolumeAttachment request.
type VolumeAttachmentStatus struct {
	// Indicates the volume is successfully attached.
	// This field must only be set by the entity completing the attach
	// operation, i.e. the external-attacher.
	Attached *bool `protobuf:"varint,1,opt,name=attached" json:"attached,omitempty"`
	// Upon successful attach, this field is populated with any
	// information returned by the attach operation that must be passed
	// into subsequent WaitForAttach or Mount calls.
	// This field must only be set by the entity completing the attach
	// operation, i.e. the external-attacher.
	// +optional
	AttachmentMetadata map[string]string `protobuf:"bytes,2,rep,name=attachmentMetadata" json:"attachmentMetadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// The last error encountered during attach operation, if any.
	// This field must only be set by the entity completing the attach
	// operation, i.e. the external-attacher.
	// +optional
	AttachError *VolumeError `protobuf:"bytes,3,opt,name=attachError" json:"attachError,omitempty"`
	// The last error encountered during detach operation, if any.
	// This field must only be set by the entity completing the detach
	// operation, i.e. the external-attacher.
	// +optional
	DetachError          *VolumeError `protobuf:"bytes,4,opt,name=detachError" json:"detachError,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *VolumeAttachmentStatus) Reset()         { *m = VolumeAttachmentStatus{} }
func (m *VolumeAttachmentStatus) String() string { return proto.CompactTextString(m) }
func (*VolumeAttachmentStatus) ProtoMessage()    {}
func (*VolumeAttachmentStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_generated_e6465b2805f8299b, []int{6}
}
func (m *VolumeAttachmentStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeAttachmentStatus.Unmarshal(m, b)
}
func (m *VolumeAttachmentStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeAttachmentStatus.Marshal(b, m, deterministic)
}
func (dst *VolumeAttachmentStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeAttachmentStatus.Merge(dst, src)
}
func (m *VolumeAttachmentStatus) XXX_Size() int {
	return xxx_messageInfo_VolumeAttachmentStatus.Size(m)
}
func (m *VolumeAttachmentStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeAttachmentStatus.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeAttachmentStatus proto.InternalMessageInfo

func (m *VolumeAttachmentStatus) GetAttached() bool {
	if m != nil && m.Attached != nil {
		return *m.Attached
	}
	return false
}

func (m *VolumeAttachmentStatus) GetAttachmentMetadata() map[string]string {
	if m != nil {
		return m.AttachmentMetadata
	}
	return nil
}

func (m *VolumeAttachmentStatus) GetAttachError() *VolumeError {
	if m != nil {
		return m.AttachError
	}
	return nil
}

func (m *VolumeAttachmentStatus) GetDetachError() *VolumeError {
	if m != nil {
		return m.DetachError
	}
	return nil
}

// VolumeError captures an error encountered during a volume operation.
type VolumeError struct {
	// Time the error was encountered.
	// +optional
	Time *v1.Time `protobuf:"bytes,1,opt,name=time" json:"time,omitempty"`
	// String detailing the error encountered during Attach or Detach operation.
	// This string maybe logged, so it should not contain sensitive
	// information.
	// +optional
	Message              *string  `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeError) Reset()         { *m = VolumeError{} }
func (m *VolumeError) String() string { return proto.CompactTextString(m) }
func (*VolumeError) ProtoMessage()    {}
func (*VolumeError) Descriptor() ([]byte, []int) {
	return fileDescriptor_generated_e6465b2805f8299b, []int{7}
}
func (m *VolumeError) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeError.Unmarshal(m, b)
}
func (m *VolumeError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeError.Marshal(b, m, deterministic)
}
func (dst *VolumeError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeError.Merge(dst, src)
}
func (m *VolumeError) XXX_Size() int {
	return xxx_messageInfo_VolumeError.Size(m)
}
func (m *VolumeError) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeError.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeError proto.InternalMessageInfo

func (m *VolumeError) GetTime() *v1.Time {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *VolumeError) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*StorageClass)(nil), "k8s.io.api.storage.v1beta1.StorageClass")
	proto.RegisterMapType((map[string]string)(nil), "k8s.io.api.storage.v1beta1.StorageClass.ParametersEntry")
	proto.RegisterType((*StorageClassList)(nil), "k8s.io.api.storage.v1beta1.StorageClassList")
	proto.RegisterType((*VolumeAttachment)(nil), "k8s.io.api.storage.v1beta1.VolumeAttachment")
	proto.RegisterType((*VolumeAttachmentList)(nil), "k8s.io.api.storage.v1beta1.VolumeAttachmentList")
	proto.RegisterType((*VolumeAttachmentSource)(nil), "k8s.io.api.storage.v1beta1.VolumeAttachmentSource")
	proto.RegisterType((*VolumeAttachmentSpec)(nil), "k8s.io.api.storage.v1beta1.VolumeAttachmentSpec")
	proto.RegisterType((*VolumeAttachmentStatus)(nil), "k8s.io.api.storage.v1beta1.VolumeAttachmentStatus")
	proto.RegisterMapType((map[string]string)(nil), "k8s.io.api.storage.v1beta1.VolumeAttachmentStatus.AttachmentMetadataEntry")
	proto.RegisterType((*VolumeError)(nil), "k8s.io.api.storage.v1beta1.VolumeError")
}

func init() {
	proto.RegisterFile("github.com/solo-io/supergloo/vendor/k8s.io/api/storage/v1beta1/generated.proto", fileDescriptor_generated_e6465b2805f8299b)
}

var fileDescriptor_generated_e6465b2805f8299b = []byte{
	// 748 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6a, 0xdb, 0x30,
	0x14, 0xc6, 0x4d, 0xda, 0x26, 0x4a, 0xc7, 0x5a, 0x51, 0x36, 0x93, 0xab, 0x60, 0x06, 0x0b, 0xa3,
	0x93, 0xd7, 0x30, 0x46, 0x19, 0xac, 0xd0, 0x6e, 0xb9, 0x58, 0xe9, 0x1f, 0x6e, 0x29, 0x63, 0x77,
	0xaa, 0x7d, 0x70, 0xb4, 0xd8, 0x96, 0x91, 0xe4, 0x6c, 0xd9, 0x3b, 0xec, 0x05, 0x36, 0xd8, 0xe5,
	0x1e, 0x70, 0x4f, 0x30, 0x24, 0x3b, 0xa9, 0x13, 0xa7, 0x6b, 0x03, 0xbd, 0x8b, 0x8e, 0xce, 0xf7,
	0x9d, 0xef, 0x7c, 0xe7, 0xc8, 0x41, 0xa7, 0x21, 0x53, 0x83, 0xec, 0x9a, 0xf8, 0x3c, 0x76, 0x25,
	0x8f, 0xf8, 0x4b, 0xc6, 0x5d, 0x99, 0xa5, 0x20, 0xc2, 0x88, 0x73, 0x77, 0x04, 0x49, 0xc0, 0x85,
	0x3b, 0xdc, 0x93, 0x84, 0x71, 0x97, 0xa6, 0xcc, 0x95, 0x8a, 0x0b, 0x1a, 0x82, 0x3b, 0xda, 0xbd,
	0x06, 0x45, 0x77, 0xdd, 0x10, 0x12, 0x10, 0x54, 0x41, 0x40, 0x52, 0xc1, 0x15, 0xc7, 0xed, 0x3c,
	0x97, 0xd0, 0x94, 0x91, 0x22, 0x97, 0x14, 0xb9, 0x6d, 0xa7, 0xc4, 0xe3, 0x73, 0xa1, 0x49, 0xe6,
	0xf1, 0xed, 0xd7, 0x37, 0x39, 0x31, 0xf5, 0x07, 0x2c, 0x01, 0x31, 0x76, 0xd3, 0x61, 0xa8, 0x03,
	0xd2, 0x8d, 0x41, 0xd1, 0x45, 0x28, 0xf7, 0x36, 0x94, 0xc8, 0x12, 0xc5, 0x62, 0xa8, 0x00, 0xde,
	0xdc, 0x05, 0x90, 0xfe, 0x00, 0x62, 0x3a, 0x8f, 0x73, 0x7e, 0xd5, 0xd1, 0xc6, 0x45, 0xde, 0xd6,
	0xfb, 0x88, 0x4a, 0x89, 0x8f, 0x51, 0x43, 0x8b, 0x0a, 0xa8, 0xa2, 0xb6, 0xd5, 0xb1, 0xba, 0xad,
	0xde, 0x2b, 0x72, 0x63, 0xc1, 0x94, 0x9b, 0xa4, 0xc3, 0x50, 0x07, 0x24, 0xd1, 0xd9, 0x64, 0xb4,
	0x4b, 0xce, 0xae, 0xbf, 0x80, 0xaf, 0x4e, 0x40, 0x51, 0x6f, 0xca, 0x80, 0x3b, 0xa8, 0x95, 0x0a,
	0x3e, 0x62, 0x92, 0xf1, 0x04, 0x84, 0xbd, 0xd2, 0xb1, 0xba, 0x4d, 0xaf, 0x1c, 0xc2, 0x9f, 0x10,
	0x4a, 0xa9, 0xa0, 0x31, 0x28, 0x10, 0xd2, 0xae, 0x75, 0x6a, 0xdd, 0x56, 0x6f, 0x8f, 0xdc, 0x6e,
	0x3a, 0x29, 0xab, 0x25, 0xe7, 0x53, 0x68, 0x3f, 0x51, 0x62, 0xec, 0x95, 0xb8, 0xf0, 0x33, 0xf4,
	0x48, 0x80, 0x1f, 0x51, 0x16, 0x9f, 0xf3, 0x88, 0xf9, 0x63, 0xbb, 0x6e, 0xaa, 0xcf, 0x06, 0xb1,
	0x83, 0x36, 0x62, 0x9e, 0x25, 0xea, 0x2c, 0x55, 0x8c, 0x27, 0xd2, 0x5e, 0xed, 0xd4, 0xba, 0x4d,
	0x6f, 0x26, 0x86, 0x7b, 0x68, 0x9b, 0x46, 0x11, 0xff, 0x7a, 0xc5, 0xa3, 0x2c, 0x86, 0xfe, 0xb7,
	0x94, 0x26, 0x5a, 0xbd, 0xbd, 0xd6, 0xb1, 0xba, 0x0d, 0x6f, 0xe1, 0x1d, 0xde, 0x41, 0x5b, 0x23,
	0x13, 0x3a, 0x64, 0x49, 0xc0, 0x92, 0xf0, 0x84, 0x07, 0x60, 0xaf, 0x1b, 0x05, 0xd5, 0x0b, 0x7c,
	0x85, 0xb6, 0x0c, 0x0b, 0x04, 0x97, 0x3c, 0xe5, 0x11, 0x0f, 0x19, 0x48, 0xbb, 0x61, 0xcc, 0xe8,
	0x96, 0xcd, 0xd0, 0x5b, 0xa6, 0xcd, 0x2e, 0xb2, 0xc6, 0x17, 0x10, 0x81, 0xaf, 0xb8, 0xb8, 0x04,
	0x11, 0x7b, 0x55, 0x8a, 0xf6, 0x3b, 0xf4, 0x78, 0xce, 0x22, 0xbc, 0x89, 0x6a, 0x43, 0x18, 0x9b,
	0xd9, 0x36, 0x3d, 0xfd, 0x13, 0x6f, 0xa3, 0xd5, 0x11, 0x8d, 0x32, 0x28, 0xc6, 0x93, 0x1f, 0xde,
	0xae, 0xec, 0x59, 0xce, 0x6f, 0x0b, 0x6d, 0x96, 0xfd, 0x3e, 0x66, 0x52, 0xe1, 0xa3, 0xca, 0x86,
	0x90, 0xfb, 0x6d, 0x88, 0x46, 0xcf, 0xed, 0xc7, 0x3e, 0x5a, 0x65, 0x0a, 0x62, 0x69, 0xaf, 0x54,
	0x7b, 0xfd, 0xdf, 0xe0, 0xbd, 0x1c, 0xe6, 0xfc, 0xb5, 0xd0, 0x66, 0xee, 0xfc, 0x81, 0x52, 0xd4,
	0x1f, 0xc4, 0x90, 0xa8, 0x07, 0x5e, 0xe1, 0x0f, 0xa8, 0x2e, 0x53, 0xf0, 0x8d, 0x39, 0xb3, 0x4c,
	0x15, 0x85, 0xf3, 0x4a, 0x2e, 0x52, 0xf0, 0x3d, 0x83, 0xc6, 0x47, 0x68, 0x4d, 0x2a, 0xaa, 0x32,
	0xbd, 0xe2, 0x9a, 0xa7, 0xb7, 0x14, 0x8f, 0x41, 0x7a, 0x05, 0x83, 0xf3, 0xc7, 0x42, 0xdb, 0xf3,
	0x29, 0x0f, 0x3e, 0x99, 0xc3, 0xd9, 0xc9, 0xec, 0x2c, 0xa3, 0x77, 0x32, 0x9d, 0x63, 0xf4, 0xa4,
	0xd2, 0x0a, 0xcf, 0x84, 0x0f, 0xfa, 0x45, 0xa5, 0x20, 0x24, 0x93, 0x0a, 0x12, 0x95, 0xe7, 0x9c,
	0xd2, 0x18, 0x8a, 0xad, 0x5c, 0x78, 0xe7, 0xfc, 0x5c, 0xd0, 0xb6, 0x76, 0x18, 0xb7, 0x51, 0x83,
	0x9a, 0x08, 0x88, 0x82, 0x60, 0x7a, 0x36, 0xbe, 0x9b, 0x92, 0xc5, 0xfc, 0x96, 0xf3, 0xdd, 0x20,
	0xbd, 0x82, 0x41, 0xd7, 0x49, 0x78, 0x90, 0x0b, 0xad, 0xe5, 0x75, 0x26, 0x67, 0xe7, 0x47, 0x6d,
	0x41, 0xaf, 0x66, 0x5c, 0x25, 0x79, 0x81, 0x91, 0xd7, 0x98, 0xca, 0x0b, 0xf0, 0x77, 0x84, 0xe9,
	0x34, 0xff, 0x64, 0x32, 0xbb, 0xdc, 0xf2, 0xa3, 0xe5, 0x57, 0x84, 0x1c, 0x54, 0xc8, 0xf2, 0xef,
	0xe2, 0x82, 0x2a, 0xf8, 0x23, 0x6a, 0xe5, 0xd1, 0xbe, 0x10, 0x5c, 0x14, 0x7b, 0xf9, 0xfc, 0xee,
	0xa2, 0x26, 0xdd, 0x2b, 0x63, 0x35, 0x55, 0x00, 0x37, 0x54, 0xf5, 0x25, 0xa9, 0x4a, 0xd8, 0x76,
	0x1f, 0x3d, 0xbd, 0xa5, 0x89, 0xa5, 0xbe, 0x5c, 0x21, 0x6a, 0x95, 0x4a, 0xe0, 0x7d, 0x54, 0xd7,
	0xff, 0x82, 0xc5, 0xab, 0x78, 0x71, 0xbf, 0x57, 0x71, 0xc9, 0x62, 0xf0, 0x0c, 0x0e, 0xdb, 0x68,
	0x3d, 0x06, 0x29, 0x69, 0x38, 0x29, 0x35, 0x39, 0x1e, 0x36, 0x3f, 0xaf, 0x17, 0x3d, 0xfd, 0x0b,
	0x00, 0x00, 0xff, 0xff, 0x1f, 0x84, 0x88, 0xa1, 0x7b, 0x08, 0x00, 0x00,
}
